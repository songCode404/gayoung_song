# 1 ) 소프트웨어 설계 구분
- 소프트웨어 설계 = **상위설계** + **하위설계** 로 구분됨
- 상위설계
	- 아키텍쳐 설계, 기본 설계
	- 시스템의 전체 구조 설계
	- DB, 인터페이스 설계
	- 비기능 요구사항
- 하위설계
	- 모듈 설계, 상세 설계
	- 시스템의 내부 동작
	- 자료구조, 알고리즘
	- 기능 요구사항

# 2 ) 소프트웨어 아키텍쳐(Software Architecture)
- SW 구성요소, 구성요소 간 관계, 상호작용을 표현한 구조
- 소프트웨어 개발의 중심축 / 뼈대

### 2-1) 아키텍쳐의 4+1 관점
- 논리적 관점 : 클래스나 컴포넌트의 종류와 관계
- 구현 관점 : 서브 시스템의 모듈 구조와 관계
- 시스템의 성능, 확장성, 효율
- 시스템의 구성
- **배치 관점**

# 3 ) 아키텍쳐 설계 (= 전체적인 구조 설계)
- 프로시저를 그룹화하고 단위그룹 수준에서 설계하는 것
- 덩어리화(chunking) 작업

### 3-1) 아키텍쳐 설계 원리 🔥🔥
- 모듈화 : 시스템 기능들을 모듈 단위로 나누는 것
- 추상화 : 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화
- 단계적 분해 : 하향식 설계 전략 / 문제를 상위 개념에서 하위 개념으로 전개
- 정보 은닉 : 한 모듈 내부의 정보가 감춰져, 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

# 4 ) 아키텍쳐 패턴
- 아키텍쳐 설계를 위한 참조 패턴

### 4-1) 아키텍쳐 패턴의 종류
- 계층형 패턴   [[1-5 .  아키텍쳐 패턴 및 디자인 패턴#4-2) 계층형(Layer) 패턴]]
- 클라이언트-서버 패턴  [[1-5 .  아키텍쳐 패턴 및 디자인 패턴#4-3) 클라이언트-서버 패턴]]
- 파이프-필터 패턴  [[1-5 .  아키텍쳐 패턴 및 디자인 패턴#4-4) 파이프-필터 패턴]]
- 브로커 패턴 [[1-5 .  아키텍쳐 패턴 및 디자인 패턴#4-5) 브로커 패턴]]
- MVC [[1-5 .  아키텍쳐 패턴 및 디자인 패턴#4-6) MVC 패턴 🔥🔥]]
- 이벤트 기반 아키텍쳐
- 데이터 중심 아키텍쳐
- 피어-투-피어

### 4-2) 계층형(Layer) 패턴
- 시스템을 계층으로 구분하여 구성하는 패턴
- 상위 계층에서 서비스를 제공
- **서로 마주보는 두 개의 계층 사이에서만 상호작용함** (EX) Layer n ---> Layer n-1 ---> Layer 1

### 4-3) 클라이언트-서버 패턴 🔥🔥
- **하나의 서버와 다수의 클라이언트로 구성**
- 서비스 = 사용자 -> 클라이언트 -> 서버 -> 클라이언트 -> 사용자 순으로 제공됨
- 서버는 클라이언트 요청에 대비하여 **항상 대기 상태를 유지**
- **서버와 클라이언트는 요청/응답을 제외하고 독립적임** (EX) 분산 시스템, 웹 서비스 
- Client <--요청 / 응답--> Server

### 4-4) 파이프-필터 패턴
- 한 필터의 출력을 다음 필터의 입력으로 넣으면서 반복적으로 처리
- 필터 = 데이터 변환 수행 / 파이프 = 데이터를 전송 (EX) UNIX 쉘, 컴파일러
- 송신 --파이프1--> Filter1 --파이프2--> Filter2 --파이프3--> 수신

### 4-5) 브로커 패턴
- 브로커 = 컴포넌트간의 통신을 조정
- 분리된 분산 시스템으로 이루어진 분산 시스템에서 사용 / 원격 서비스 실행을 통해 서로 상호작용 가능
- Client <--> Broker <--> Server 1
			 |<---> Sever 2 
			 |<---> Sever 3

### 4-6) MVC 패턴 🔥🔥
- M = Model / V = View / C = Controller
	- Model = 핵심 기능과 데이터를 보관
	- View = 사용자에게 정보를 표시
	- Controller = 사용자 요청을 입력받아 처리
- 데이터 처리 부분과 표현 기능을 분리, 재사용성 증진

# 5 ) 디자인 패턴
### 5-1) 디자인 패턴의 개요
- 하위 단계의 모듈 설계 시 참조하는 해결 방식 또는 예제

# 6 ) GOF의 디자인 패턴 분류 🔥🔥🔥
### 6-1) 디자인 패턴 유형 
- 생성 패턴 : 객체 생성에 관여 / 클래스 정의와 객체 생성 방식을 구조화, 캡슐화 수행, 5가지 패턴 [[1-5 .  아키텍쳐 패턴 및 디자인 패턴#6-2) 생성 패턴 (생추 빌팩 프로싱)🔥🔥🔥🔥🔥]]
- 구조 패턴 : 클래스나 객체를 **조합하여 더 큰 구조를 만드는 패턴**, 7가지 패턴 [[1-5 .  아키텍쳐 패턴 및 디자인 패턴#6-3) 구조 패턴(구어부 컴텍 퍼플록) 🔥🔥🔥🔥🔥]]
- 행위 패턴 : 클래스나 객체들이 **상호작용하는 방법과 알고리즘** 등을 정의하는 패턴, 11가지 패턴

### 6-2) 생성 패턴 (생추 빌팩 프로싱)🔥🔥🔥🔥🔥
- 추상 팩토리(Abstract Factory)
	- 구체적인 클래스에 의존 X
	- **인터페이스를 통해 서로 연관, 의존하는 객체들을 그룹으로 생성하여 추상적으로 표현**
- 빌더(Builder)
	- **객체 생성과정과 표현 방법을 분리하고 있음**
	- **작게 분리된** 인스턴스를 건죽하듯 조합하여 객체 생성
- **팩토리 메소드(Factory Method)**
	- **상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함**
	- 가상 생성자 패턴이라고도 함
- 프로토타입(Prototype)
	- 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
- 싱글톤(Singleton)
	- **클래스 내에서 인스턴스가 하나뿐임을 보장**하며 불필요한 메모리 낭비를 최소화

### 6-3) 구조 패턴(구어부 컴텍 퍼플록) 🔥🔥🔥🔥🔥
- 어댑터(Adapter)
	-  **호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴**
- 브리지(Bridge)
	- **기능과 구현을 2개의 별도 클래스로 구현**
	- 구현부에서 추상층을 분리하여 서로 독립적으로 확장할 수 있도록 구성한 패턴
- 컴포지트(Composite)
	- **여러 객체를 가진 복합 개체와 단일 객체를 구분없이 다룰 때 사용하는 패턴**
- 데코레이터(Decorator)
	- 객체 간 결합을 통해 **동적으로 기능들을 확장할 수 있는 패턴**
	- 임의 객체에 부가적 기능 추가를 위해 다른 객체들을 덧붙이는 방식으로 구현
- 퍼싸드(Facade)
	- **복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성**하여 서브 클래스들의 기능을 간편하게 사용
- 플라이웨이트(Flyweight)
	- 인스턴스 필요시 매번 생성 X --> **가능한 공유해서 사용**
- 프록씨(Proxy)
	- 접근이 어려운 객체와 해당 객체에 연결하려는 객체 사이에서 인터페이스 역할을 수행

### 6-4) 행위패턴
- 책임 연쇄(Chain of Responsibility) 
	- **요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어감**
- 커맨드(Command)
	- 요청을 객체 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 필요한 정보를 저장하거나 로그에 남김
- 인터프리터(Interpreter)
	- 언어에 문법 표현을 정의하는 패턴 -> SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용
- 반복자(Iterator)
	- **자료구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴**
	- 내부 표현 방법의 노출 없이 순차적인 접근 가능
- 중재자(Mediator)
	- 수많은 객체와 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
	- 객체 사이의 의존성을 줄여 결합도 감소 가능
- 메멘토(Memento)
	- 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 되돌릴 수 있는 기능을 제공
	- Ctrl+Z와 같은 되돌리기 기능을 개발할 때 주로 이용
- **옵서버(Observer)**
	- **한 객체의 상태가 변화되면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴**
- 상태(State)
	- 객체 상태에 따라 동일 동작을 다르게 처리할 때 사용하는 패턴
	- 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리
- 전략(Strategy)
	- **동일 계열 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴**
- 템플릿 메소드(Template Method)
	- 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
- 방문자(Visitor)
	- 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도 클래스로 구성하는 패턴
	- 분리된 처리 기능은 각 클래스를 방문하여 수행함

>[!test]
>디자인 패턴 중 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가서 자동으로 내용이 갱신되는 방식으로 일대다의 의존성을 정의하는 패턴이다. 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 패턴을 영문으로 쓰시오.
>
>
>Observer(옵서버 패턴)

>[!test]
>소프트웨어 공학의 디자인 패턴(Design Pattern)에 대한 다음 설명에서 괄호에 알맞은 답을 쓰시오.
> - 디자인 패턴은 1995년 Gof라고 불리는 에릭 감마, 리차드 헬름, 랄프 존슨, 존 블리시디스가 처음으로 구체화 및 체계화하였다.
> - 디자인 패턴은 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함으로써, 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴이다.
> - 디자인 패턴은 23가지로 생성, 구조, (     )의 3가지로 구분한다.
>   
>   행위


>[!test]
>디자인 패턴 중 (       ) 패턴은 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.
>괄호 안에 알맞은 패턴을 적으시오.
>
>팩토리 메소드(Factory Method)

>[!test] 
>디자인 패턴 중 (     ) 패턴은 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로 클래스나 객체들이 상호작용하는 방법, 알고리즘 등과 관련된 패턴이다. 괄호안에 들어갈 용어를 적으시오.
>
>예시 : Interpreter, Observer, Command, Iterator, Strategy, Vister
>
>행위

